<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Haakon Bakka" />


<title>A simple spatial model: Simulation-inference</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cerulean.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="hcstyle.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">My Website</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="organisedtopics.html">Organised Topics</a>
</li>
<li>
  <a href="alltopics.html">All Topics</a>
</li>
<li>
  <a href="aboutme.html">About me</a>
</li>
<li>
  <a href="feedback.html">Feedback</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">A simple spatial model: Simulation-inference</h1>
<h4 class="author">Haakon Bakka</h4>
<h4 class="date">BTopic122 updated 06. Nov 2018</h4>

</div>



<div id="about" class="section level1">
<h1><span class="header-section-number">1</span> About</h1>
<p>This topic is a simple example of a spatial model, with simulation and then inference. By simulating the data I aim to show the structure of a spatial hierarchical model.</p>
<div id="initialisation" class="section level2">
<h2><span class="header-section-number">1.1</span> Initialisation</h2>
<p>We load libraries, including INLA (<a href="btopic109.html">Installation and general troubleshooting</a>).</p>
<pre class="r"><code>library(INLA)
library(fields)
library(ggplot2)
library(viridisLite)</code></pre>
<p>We remove all variables in the workspace (you may want to remove this), and set the random seeds (so you can replicate the results).</p>
<pre class="r"><code>rm(list=ls())
set.seed(201803)
inla.seed = sample.int(n=1E6, size=1)
options(width=70, digits=3)</code></pre>
</div>
<div id="dependency-plot-spatial-fields" class="section level2">
<h2><span class="header-section-number">1.2</span> Dependency: Plot spatial fields</h2>
<p>The following function shows how to plot a spatial field. This is done by projecting the values at the mesh nodes on to a fine grid. We will skip over the explanation for now, and just consider it a black box function.</p>
<pre class="r"><code>local.plot.field = function(field, mesh, xlim=c(0,10), ylim=c(0,10), ...){
  stopifnot(length(field) == mesh$n)
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(300, 300))
  field.proj = inla.mesh.project(proj, field)
  n.col = 20
  image.plot(list(x = proj$x, y=proj$y, z = field.proj), 
             xlim = xlim, ylim = ylim, col = plasma(n.col), nlevel=n.col+1, ...)
}</code></pre>
<p>The default values for <code>xlim</code> and <code>ylim</code> shows the spatial region we use in this topic.</p>
</div>
</div>
<div id="the-spatial-random-effect-us" class="section level1">
<h1><span class="header-section-number">2</span> The spatial random effect <span class="math inline">\(u(s)\)</span></h1>
<p>The original paper introducing the SPDE approach for INLA was written by <span class="citation">Lindgren, Rue, and Lindström (2011)</span>, and a recent review was written by <span class="citation">Bakka et al. (2018)</span>.</p>
<p>The hierarchical Bayesian model describes the data <span class="math inline">\(y\)</span> by an iid observation likelihood, <span class="math display">\[y_i | \eta_i \sim L(y_i|\eta_i),\]</span> where <span class="math display">\[\eta_i = \beta_0 + X_i\beta + u_i, \]</span> with <span class="math inline">\(u_i = u(s_i)\)</span>.</p>
<p>The model we want for the spatial effect <span class="math inline">\(u\)</span> is <span class="math display">\[\boldsymbol u | r, \sigma_u \sim \mathcal N(0, \Sigma) \]</span> Here, <span class="math inline">\(\Sigma_{r, \sigma}\)</span> is the Mat' ern covariance with range <span class="math inline">\(r\)</span> and marginal standard deviation <span class="math inline">\(\sigma\)</span> (with smoothness 1).</p>
<p>To get this, we will create a mesh, construct the Mat' ern model on the mesh, and project it to the data locations with a so-called <span class="math inline">\(A\)</span>-matrix. Let us call the vector of values on the mesh for <code>field</code>, or <span class="math inline">\(f_s\)</span>, and <span class="math inline">\(\boldsymbol u\)</span> is the vector of the fields values at the observation locations, then <span class="math display">\[\boldsymbol u = A f_s, \]</span> In code <code>u = A %*% field</code>.</p>
</div>
<div id="simulate-the-spatial-random-effect" class="section level1">
<h1><span class="header-section-number">3</span> Simulate the spatial random effect</h1>
<div id="set-true-parameter-values-for-the-spatial-effect" class="section level2">
<h2><span class="header-section-number">3.1</span> Set true parameter values for the spatial effect</h2>
<pre class="r"><code>sigma.u = 1.5
# - the marginal standard deviation of the spatial field
range = 2
# - the correlation range of the spatial field
#kappa = sqrt(8)/range
# - kappa was the parameter we used in previous years
# - not used in this code, but you may encounter it</code></pre>
</div>
<div id="create-a-mesh" class="section level2">
<h2><span class="header-section-number">3.2</span> Create a mesh</h2>
<p>We use a mesh since simulating using a covariance matrix is slow.</p>
<pre class="r"><code>fake.locations = matrix(c(0,0,10,10, 0, 10, 10, 0), nrow = 4, byrow = T)
mesh.sim = inla.mesh.2d(loc = fake.locations, max.edge=c(0.4, 1))</code></pre>
<p>We then look at the mesh to check that it is no unreasonable. My quick rules of thumb is that the outer extension is greater than 2/3 the <code>range</code>, and that the <code>max.edge</code> is smaller than 1/5 of the <code>range</code>. (If the true range is not known, we may need to run INLA more than once.)</p>
<pre class="r"><code>plot(mesh.sim)
axis(1); axis(2)</code></pre>
<p><img src="btopic122_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
</div>
<div id="simulate-spatial-field" class="section level2">
<h2><span class="header-section-number">3.3</span> Simulate spatial field</h2>
<p>We use the term spatial “field” for one continuous field in the entire study area. We use the term spatial “effect” for the entire model component, including hyper-parameters. When setting up the <code>spde</code> object for simulating, the prior is never used. We just plug in 0.5 everywhere as this gives no errors.</p>
<pre class="r"><code>spde = inla.spde2.pcmatern(mesh.sim, prior.range = c(.5, .5), prior.sigma = c(.5, .5))

Qu = inla.spde.precision(spde, theta=c(log(range), log(sigma.u)))
u = inla.qsample(n=1, Q=Qu, seed = inla.seed)
u = u[ ,1]</code></pre>
<pre class="r"><code>local.plot.field(u, mesh.sim)
len = range
# - the true range
arrows(5-0.5*len, 6, 5+0.5*len, 6, length=0.05, angle=90, code=3, lwd=3)</code></pre>
<p><img src="btopic122_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
</div>
<div id="simulate-at-measurement-locations" class="section level2">
<h2><span class="header-section-number">3.4</span> Simulate at measurement locations</h2>
<p>The simulation we have so far is a continuous simulation for the entire study area. Now we want to project this to a set of observation locations.</p>
<pre class="r"><code>n = 5*1E3
# - number of measurement locations
# - Don&#39;t do more than 5000 if you want the code to be quick to run (1 minute)
# - can do 100*1E3

loc.data = matrix(runif(2*n), n)*10 # coordinates
# - We pick the locations uniformly at random.</code></pre>
</div>
<div id="project-u-to-loc.data" class="section level2">
<h2><span class="header-section-number">3.5</span> Project <code>u</code> to <code>loc.data</code></h2>
<pre class="r"><code>A = inla.spde.make.A(mesh=mesh.sim, loc=loc.data)
u = drop(A %*% u)</code></pre>
<p>We use one of my favourite functions to plot this on an approximated locations grid.</p>
<pre class="r"><code>quilt.plot(x=loc.data[, 1],y=loc.data[, 2],z=u,nx=80,ny=80, 
           col = plasma(101), main=&quot;Field projected to data locations&quot;, 
           zlim = range(u))</code></pre>
<p><img src="btopic122_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
</div>
</div>
<div id="simulate-the-predictor-and-the-data" class="section level1">
<h1><span class="header-section-number">4</span> Simulate the predictor and the data</h1>
<p>The observation likelihood is <span class="math display">\[y_i \sim \mathcal N(\eta_i, \sigma_\epsilon) \]</span></p>
<p>The <span class="math inline">\(\sigma_\epsilon\)</span> is also known as: <span class="math inline">\(\sigma_{iid}\)</span>, <code>sigma.iid</code>, and <code>sigma.epsilon</code>.</p>
<pre class="r"><code>sigma.iid = 0.3
# - set the true value</code></pre>
<p>Further, the linear predictor is <span class="math display">\[\eta_i = \beta_1 + \beta_2 x + u(s_i),\]</span> where <span class="math inline">\(u(s_i) = u_i\)</span> is the spatial field projected to the data locations <span class="math inline">\(s_i\)</span>. As code, this linear predictor will be represented by <code>formula = y ~ -1 + intercept + x + f(s, model = spde)</code> when fitting the model</p>
<div id="the-linear-predictor-level" class="section level2">
<h2><span class="header-section-number">4.1</span> The linear predictor level</h2>
<p>Set true parameter values</p>
<pre class="r"><code>x = runif(n)-0.5
# - mean 0 to not affect intercept
beta = c(1, 2) 
# - define true beta coefficients</code></pre>
<p>Next we construct the linear predictor.</p>
<pre class="r"><code>lin.pred = beta[1] + beta[2]*x + u
# the true lin predictor</code></pre>
</div>
<div id="the-observation-level" class="section level2">
<h2><span class="header-section-number">4.2</span> The observation level</h2>
<pre class="r"><code>y = lin.pred + sigma.iid*rnorm(n)
# - the observed data</code></pre>
<pre class="r"><code>quilt.plot(x=loc.data[, 1],y=loc.data[, 2],z=y,nx=80,ny=80, 
           col = plasma(101), main=&quot;Observed data&quot;, 
           zlim = range(y))</code></pre>
<p><img src="btopic122_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
</div>
<div id="prepare-dataframe" class="section level2">
<h2><span class="header-section-number">4.3</span> Prepare dataframe</h2>
<p>This dataframe is the only object our inference is allowed to use.</p>
<pre class="r"><code>df = data.frame(y=y, locx=loc.data[ ,1], locy=loc.data[ ,2], x = x)
summary(df)</code></pre>
<pre><code>##        y              locx            locy             x         
##  Min.   :-3.90   Min.   : 0.00   Min.   : 0.00   Min.   :-0.500  
##  1st Qu.:-0.07   1st Qu.: 2.55   1st Qu.: 2.53   1st Qu.:-0.255  
##  Median : 1.04   Median : 4.93   Median : 5.08   Median : 0.003  
##  Mean   : 1.04   Mean   : 4.98   Mean   : 5.06   Mean   :-0.002  
##  3rd Qu.: 2.12   3rd Qu.: 7.36   3rd Qu.: 7.58   3rd Qu.: 0.249  
##  Max.   : 6.00   Max.   :10.00   Max.   :10.00   Max.   : 0.500</code></pre>
</div>
</div>
<div id="coding-the-spatial-effect-for-inference" class="section level1">
<h1><span class="header-section-number">5</span> Coding the spatial effect for inference</h1>
<div id="mesh-and-a-matrix" class="section level2">
<h2><span class="header-section-number">5.1</span> Mesh and A matrix</h2>
<p>The choice of mesh should not matter too much, and we do not need to use the same mesh for simulation and for inference.</p>
<pre class="r"><code>mesh = inla.mesh.2d(loc = fake.locations, max.edge=c(0.4, 1))
mesh$n</code></pre>
<pre><code>## [1] 2433</code></pre>
<pre class="r"><code>A = inla.spde.make.A(mesh=mesh, loc=data.matrix(df[ , c(&#39;locx&#39;, &#39;locy&#39;)]))
dim(A); </code></pre>
<pre><code>## [1] 5000 2433</code></pre>
<p>Plot the mesh and data; for diagnostics</p>
<pre class="r"><code>par(mar=c(1,1,1,1))
plot(mesh, asp=1)
points(df[ , c(&#39;locx&#39;, &#39;locy&#39;)], col=&#39;red&#39;, lwd=.1)</code></pre>
<p><img src="btopic122_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
</div>
<div id="spatial-effect-prior-model" class="section level2">
<h2><span class="header-section-number">5.2</span> Spatial effect: Prior model</h2>
<pre class="r"><code>prior.median.sd = 1; prior.median.range = 5
spde = inla.spde2.pcmatern(mesh, prior.range = c(prior.median.range, .5), prior.sigma = c(prior.median.sd, .5))</code></pre>
</div>
<div id="stack" class="section level2">
<h2><span class="header-section-number">5.3</span> Stack</h2>
<pre class="r"><code>stack = inla.stack(tag=&#39;est&#39;,
                    # - Name (nametag) of the stack
                    # - Here: est for estimating
                    data=list(y=df$y),
                    effects=list(
                      # - The Model Components
                      s=1:spde$n.spde, 
                      # - The first is &#39;s&#39; (for spatial)
                     data.frame(intercept=1, x=df$x)),
                      # - The second is all fixed effects
                    A=list(A, 1)
                    # - First projector matrix is for &#39;s&#39;
                    # - second is for &#39;fixed effects&#39;
                    )</code></pre>
</div>
<div id="observation-likelihood" class="section level2">
<h2><span class="header-section-number">5.4</span> Observation likelihood</h2>
<p>We assume, <span class="math display">\[\epsilon_i \sim \mathcal N(0, \sigma_\epsilon^2) \]</span> and use the prior, <span class="math display">\[\sigma_\epsilon \sim \exp(\lambda) \]</span> where <span class="math inline">\(\lambda\)</span> is determined by setting the prior median. In this prior assumption we assume that some of the variability in the data <code>sd(y)=</code> 1.553 has been explained by the covariates (by modeling the “mean”).</p>
<pre class="r"><code>family = &quot;gaussian&quot;
prior.median.sd.g = 0.5 # prior median for sigma.epsilon
control.family = list(hyper = list(prec = list(
              prior = &quot;pc.prec&quot;, param =
                c(prior.median.sd.g,0.5))))</code></pre>
</div>
</div>
<div id="model-fitting" class="section level1">
<h1><span class="header-section-number">6</span> Model fitting</h1>
<pre class="r"><code>formula = y ~ -1 + intercept + x + f(s, model=spde)
# - Remove standard intercept (always when using inla.stack)
# - Fixed effects + random effects
# - s belongs to the mesh
# - A-matrix will tell inla() how to go from mesh to data

initial.theta = c(2.35, 0.79, 0.46)
# - the first time you run this, set it to NULL
# - after running, set it to res$internal.summary.hyperpar$mean
# - and run the code again
# - Reason: Both faster and better inference

res = inla(formula, data=inla.stack.data(stack),
            family = family,
            control.family = control.family,
            control.predictor=list(A = inla.stack.A(stack)),
            quantiles=c(0.5, 0.025, 0.975, 0.1, 0.9, 0.25, 0.75),
            #control.compute = list(config=T, dic=T, cpo=T, waic=T), 
            # - Model comparisons
            #control.inla = list(int.strategy=&#39;grid&#39;),
            # - More accurate integration over hyper-parameters
            control.mode = list(restart = T, theta = initial.theta))</code></pre>
<p>We just show the default summary.</p>
<pre class="r"><code>summary(res)</code></pre>
<pre><code>## 
## Call:
##    c(&quot;inla(formula = formula, family = family, data = 
##    inla.stack.data(stack), &quot;, &quot; quantiles = c(0.5, 0.025, 0.975, 
##    0.1, 0.9, 0.25, 0.75), control.predictor = list(A = 
##    inla.stack.A(stack)), &quot;, &quot; control.family = control.family, 
##    control.mode = list(restart = T, &quot;, &quot; theta = 
##    initial.theta))&quot;) 
## Time used:
##     Pre = 1.66, Running = 12, Post = 0.11, Total = 13.8 
## Fixed effects:
##           mean    sd 0.5quant 0.025quant 0.975quant 0.1quant 0.9quant
## intercept 0.92 0.291    0.923      0.332       1.49     0.55     1.28
## x         2.00 0.017    1.996      1.962       2.03     1.97     2.02
##           0.25quant 0.75quant  mode kld
## intercept     0.731      1.11 0.929   0
## x             1.985      2.01 1.996   0
## 
## Random effects:
##   Name     Model
##     s SPDE2 model
## 
## Model hyperparameters:
##                                          mean    sd 0.5quant
## Precision for the Gaussian observations 10.38 0.247    10.37
## Range for s                              1.99 0.199     1.97
## Stdev for s                              1.47 0.123     1.46
##                                         0.025quant 0.975quant
## Precision for the Gaussian observations       9.89      10.87
## Range for s                                   1.65       2.43
## Stdev for s                                   1.25       1.74
##                                         0.1quant 0.9quant 0.25quant
## Precision for the Gaussian observations    10.06    10.69     10.21
## Range for s                                 1.75     2.26      1.85
## Stdev for s                                 1.32     1.63      1.38
##                                         0.75quant  mode
## Precision for the Gaussian observations     10.54 10.37
## Range for s                                  2.12  1.93
## Stdev for s                                  1.54  1.43
## 
## Expected number of effective parameters(stdev): 1087.66(15.82)
## Number of equivalent replicates : 4.60 
## 
## Marginal log-Likelihood:  -2726.65</code></pre>
</div>
<div id="plots" class="section level1">
<h1><span class="header-section-number">7</span> Plots</h1>
<p>Let us look at my favourite summaries and plots of the result.</p>
<div id="visualising-posterior-of-hyper-parameters" class="section level2">
<h2><span class="header-section-number">7.1</span> Visualising posterior of hyper-parameters</h2>
<pre class="r"><code>local.plot.quant = function (quantiles, truth = NA) {
  cn = colnames(quantiles)
  ids = setdiff(grep(&quot;quant&quot;, cn), which(cn==&quot;0.5quant&quot;))
  qu = quantiles[ids]
  #plot(rep(c(1,2,NA), length(qu)), rep(qu, each=3), type=&quot;p&quot;, pch=19, xaxt=&quot;n&quot;, xlab = rownames(quantiles), ylab=&quot;n&quot;)
  plot(c(1,2,rep(1.5, length(qu)), NA), c(NA,NA, qu, truth), type=&quot;p&quot;, pch=18, xaxt=NULL, xlab = rownames(quantiles), ylab=&quot;n&quot;)
  points(c(rep(1.5, 2)), range(qu), type=&quot;p&quot;, pch=18,cex=2)
  points(1.5, quantiles[which(cn==&quot;0.5quant&quot;)], pch=19, cex=2)
  if (!is.na(truth)) {
    lines(c(1.2,1.8), rep(truth, 2), col=&quot;blue&quot;, lwd=2)
  }
}</code></pre>
<pre class="r"><code>par(mfrow=c(1,4), mar=c(5.1, 2.1, 0.1, 1.1))
q1 = sqrt(1/res$summary.hyperpar[1, ])
rownames(q1) = &quot;Sigma for obs&quot;
local.plot.quant(q1, truth = sigma.iid)
local.plot.quant(res$summary.hyperpar[2, ], truth = range)
local.plot.quant(res$summary.hyperpar[3, ], truth = sigma.u)</code></pre>
<p><img src="btopic122_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<pre class="r"><code>par(mfrow=c(1,4), mar=c(5.1, 2.1, 0.1, 1.1))
local.plot.quant(res$summary.fixed[1, ], truth = beta[1])
local.plot.quant(res$summary.fixed[2, ], truth = beta[2])</code></pre>
<p><img src="btopic122_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
</div>
</div>
<div id="visualise-random-effect" class="section level1">
<h1><span class="header-section-number">8</span> Visualise random effect</h1>
<p>We now visualise what we call “parameters”, namely the <span class="math inline">\(u(s)\)</span> (or <span class="math inline">\(f(s)\)</span>, <span class="math inline">\(f_s\)</span>) for the random effect. The difficulty with visualising these is that there are so many of them:</p>
<pre class="r"><code>nrow(res$summary.random$s)</code></pre>
<pre><code>## [1] 2433</code></pre>
<p>We will not only viusualise these at the data locations, but everywhere in the study area.</p>
<pre class="r"><code>local.plot.field(res$summary.random[[&#39;s&#39;]][[&#39;mean&#39;]], mesh)
len = res$summary.hyperpar[2, &#39;0.5quant&#39;]
# - the posterior median range
arrows(5-0.5*len, 5, 5+0.5*len, 5, length=0.05, angle=90, code=3, lwd=3)</code></pre>
<p><img src="btopic122_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<p>We can visualise the posterior <code>sd</code> or quantiles in a similar way (commented out).</p>
<pre class="r"><code>#local.plot.field(res$summary.random[[&#39;s&#39;]][[&#39;sd&#39;]], mesh, colors = NULL)
#points(x = df$locx, y=df$locy, lwd = .1)</code></pre>
</div>
<div id="comments" class="section level1">
<h1><span class="header-section-number">9</span> Comments</h1>
<div id="exercises" class="section level2">
<h2><span class="header-section-number">9.1</span> Exercises</h2>
<ol style="list-style-type: decimal">
<li>Draw more samples from the prior spatial random effect</li>
<li>Find rules for guessing sigma and range based on a sample of <span class="math inline">\(u\)</span></li>
<li>Change the likelihood to poisson</li>
<li>Hold out 10% of the data and compare point predictions to truth</li>
</ol>
</div>
<div id="point-estimates" class="section level2">
<h2><span class="header-section-number">9.2</span> Point estimates</h2>
<p>I use medians as point estimates for hyper-parameters, but for parameters on the scale of the linear predictor I use the mean, because the mean function is linear (and we want to add up components of the linear predictor).</p>
</div>
<div id="signal-to-noise" class="section level2">
<h2><span class="header-section-number">9.3</span> Signal-to-noise</h2>
<pre class="r"><code>sigma.u/sigma.iid</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code># - one of the &quot;signal-to-noise&quot; ratios
# - this value is more important than either of the sigma values
# - experiment with changing the sigma values to see what I mean</code></pre>
<div id="visualising-posterior-of-hyper-parameters-1" class="section level3">
<h3><span class="header-section-number">9.3.1</span> Visualising posterior of hyper-parameters</h3>
<p>For the hyper-parameters, I used to plot the posterior marginals, but now I only visualise the quantiles. The main reason for this is that marginals are easy to misinterpret, as the probability density depends on the choice of parametrisation. For example, in some parametrisation the posterior is bimodal, and in some other parametrisation some imporatant part of the probability mass is so far into the tail that any plot window is too small.</p>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-bakka2018spatial">
<p>Bakka, Haakon, Håvard Rue, Geir-Arne Fuglstad, Andrea Riebler, David Bolin, Elias Krainski, Daniel Simpson, and Finn Lindgren. 2018. “Spatial Modelling with R-Inla: A Review.” <em>arXiv Preprint arXiv:1802.06350</em>.</p>
</div>
<div id="ref-lindgren2011spdeapproach">
<p>Lindgren, Finn, Håvard Rue, and Johan Lindström. 2011. “An Explicit Link Between Gaussian Fields and Gaussian Markov Random Fields: The Stochastic Partial Differential Equation Approach.” <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> 73 (4). Blackwell Publishing Ltd: 423–98. <a href="https://doi.org/10.1111/j.1467-9868.2011.00777.x">https://doi.org/10.1111/j.1467-9868.2011.00777.x</a>.</p>
</div>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
